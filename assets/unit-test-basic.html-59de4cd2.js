import{_ as i,W as e,X as a,a1 as t}from"./framework-b609eea8.js";const l="/assets/image-20230403142240-ffe6e1c8.png",c="/assets/image-20230403135621-a66ea36a.png",o="/assets/image-20230403135924-f771f439.png",s="/assets/image-20230403140302-c5d5bef0.png",r={},n=t('<h1 id="单元测试基本概念" tabindex="-1"><a class="header-anchor" href="#单元测试基本概念" aria-hidden="true">#</a> 单元测试基本概念</h1><h2 id="单元测试是什么" tabindex="-1"><a class="header-anchor" href="#单元测试是什么" aria-hidden="true">#</a> 单元测试是什么？</h2><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统。</p><h2 id="为什么要使用ut" tabindex="-1"><a class="header-anchor" href="#为什么要使用ut" aria-hidden="true">#</a> 为什么要使用UT？</h2><p>有很大一部分项目中都存在缺少ut或者覆盖率不高的情况，这种现象在业务体量大、开发人员少的项目组中非常常见，而导致这样的原因无非是以下几种：</p><ol><li>业务需求过多，产品一直在给新需求，本身开发时间已经被大量缩减，更别提测试了</li><li>没有测试人员，需求从开发到上线都是开发人员自己负责，自己对自己的代码总是充满自信的</li><li>维护成本过高，每次改动逻辑，又有对应的case要进行修改</li><li>不会写</li></ol><p>可见，ut是有一定的成本的，那么在这样的成本下给我们带来的好处是什么呢？</p><p>先来看一个测试模型：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个模型图的大致意思就是，越是靠近底层的测试，所达到的效果越好，反之则效果越差。也就是说，大部分公司所做的界面功能测试，其实是效率最差的一种测试方式，同时也可以看到，最底层的ut属于是白盒，越向上，黑盒的程度也越大，自动化测试的难度也就越高。而最底层的ut则实现自动化测试最为简单。</p><h2 id="unit-test-integration-test" tabindex="-1"><a class="header-anchor" href="#unit-test-integration-test" aria-hidden="true">#</a> Unit Test &amp; Integration Test</h2><p>单元测试和集成测试的界线我相信大部分开发也是不清晰的。个人理解单元测试针对于一块业务逻辑最小的单元，太抽象。物理上可以简单理解为一个类的方法， 可以是public方法也可以是private方法。一个单元测试不应该包含外部依赖的逻辑，反之就是集成测试了。 问题的核心就在于此。一个service的一个接口实现可能依赖很多第三方：</p><ol><li>本地其它的service</li><li>dao调用</li><li>rpc调用</li><li>微服务调用。</li></ol><p>如下图：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也就是说你的单元测试，真正调用了外部依赖那就是集成测试。这其实很常见对不？我们先说这种情况下如何集成测试。</p><h3 id="local-integration-test" tabindex="-1"><a class="header-anchor" href="#local-integration-test" aria-hidden="true">#</a> Local Integration Test</h3><p>本地集成测试也就是说不依赖与其他进程。包括：service依赖其他本地service或者dao的情况。在讲述如何集成测试之前，我们先理一下测试模型，测试主要包含三块内容：1.数据准备 2.执行逻辑 3.输出验证。</p><ol><li>数据准备 在本地集成测试里，数据来源基本上来自于dao，dao来自于sql。也就是在执行一个case之前，执行一些sql脚本，数据库则使用h2这类memory database， 切记不要依赖公司测试环境的db。下图是使用spring-test框架的一个case，可以在case执行之前准备我们所需要的各种数据， 另外在执行完case之后，执行clean.sql脚本来清理脏数据。这里也说明一个case的执行环境是完全独立的，case之间互不干扰，这很重要。</li></ol><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>执行逻辑最简单，就是调用一下我们测试的方法即可</li><li>验证 集成测试一般是调用service，或者dao的接口验证。</li></ol><p>举个例子：CRUD操作的集成测试</p><ol><li>调用C接口</li><li>调用R接口，验证C成功</li><li>调用U接口</li><li>调用R接口，验证U成功</li><li>调用D接口</li><li>调用R接口，验证D成功</li></ol><h3 id="remote-integration-test" tabindex="-1"><a class="header-anchor" href="#remote-integration-test" aria-hidden="true">#</a> Remote Integration Test</h3><p>假设我们一个service实现依赖某个RPC Service</p><ol><li><p>数据准备 跑到别人家的数据库插几条数据？或者跟PRC Service的Owner商量好，搭一个测试环境供我们测试？有些公司还真有专门的自动化测试环境，那么即使有测试环境，那如何实现各种case场景下，第三方Service很配合的返回数据给我们？想想都蛋疼。</p></li><li><p>执行方法 假设我们成功的解决了第一步中的问题，皆大欢喜。现在来看第二步，假设我们的service里面调用了另一个RPC Service创建了很多数据，跑了无数次case，结果....RPC Service对应的数据库都是我们的脏数据，如何清理？而且他们敢随便删数据吗？想想也蛋疼。</p></li><li><p>输出验证 假设我们又愉快的解决了第二步中的问题。现在来看第三步，假设我们的方法执行最终输出是创建了一个订单，订单当然是调用订单Service接口了，那么我们如何验证订单是否成功创建了呢？或许可以调用订单Service查询订单的接口来验证。很明显大多数情况下并没有这么完美。想想也蛋疼呀。</p></li></ol><p>通过以上分析，Local Integration Test是可行的，Remote Integration Test基本不可行。</p><p>那么有没有什么办法解决呢？答案就是Mock</p><ul><li>第一步：Mock RPC Service 想返回什么数据就返回什么数据</li><li>第二步：还是Mock接口，想调用几次就调用几次</li><li>第三步：这一步等到下面讲完单元测试就明白了</li></ul><h3 id="unit-test" tabindex="-1"><a class="header-anchor" href="#unit-test" aria-hidden="true">#</a> Unit Test</h3><p>上面我们谈到Mock可以解决外部依赖的问题，现在有很多Mock的开源框架比如：mockito。那么问题来了，既然我们可以mock第三方远程依赖，为何不mock dao、local service呢？没错外部依赖全部mock掉，就是单元测试了。因为我们只关心所测试的方法的业务逻辑，也就是真正高内聚的逻辑单元了。如下图：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>好处如下：</p><ol><li>没有什么数据是造不出来的，通通返回Mock的对象</li><li>代码中的异常处理代码，也可以通过mock接口，使之抛出异常</li><li>不产生任何脏数据</li><li>跑case更快了，因为不用启动整个项目，相当于Main方法</li></ol><p>有人会说，都mock了还测试个蛋蛋。</p><p>这就是对于单元测试的理解了，单元测试应该只针对于目标方法的业务逻辑测试，dao、其它service应该在它们自身的单元测试去测试。对于依赖的第三方，我们应该信任它们能正确的完成我们所预期的。这句话很难理解对不对？</p><p>举几个例子</p><p>例子一：方法的最后是执行dao的create操作，那么该如何验证？</p><p>我们应该验证的内容是：</p><ol><li>dao的create方法被调用了</li><li>调用次数是对的</li><li>调用参数也是对的</li></ol><p>没错，只要这三个验证通过，那么这个case执行就是通过的。因为我们相信dao的create操作能正确的完成我们所预期的，只要我们调用了正确的次数并且参数都是对的。dao的执行的正确性保证是在该dao的单元测试做的。 在Remote Integration Test里面第三步验证道理是一样的，我们应该验证RPC接口被调用了且次数和参数都是对的，那么我们的case就算通过了，至于，RPC服务端是否正确执行是它们的事情不是我们所关心的。 Mockito框架的verify接口就是做这件事情的。如果你理解了上述内容，那么你就开窍了，UT不在变得这么难写。</p><p>什么时候用单元测试，什么时候用集成测试？</p><p>对于简单的业务，比如crud型的瘦service，比较适合于集成测试。</p><p>以下情况适合于单元测试：</p><ul><li>Util类</li><li>含有远程调用的方法</li><li>输入少，业务逻辑复杂的方法</li><li>需要异常处理的方法</li></ul><p>case细到什么程度为好？ 这个问题也是比较经典的，一个方法要是所有的路径都覆盖到，那么要写很多的case，说真的累死人。我的建议是两个原则：</p><p>核心逻辑，容易出错的逻辑一定要覆盖到 根据自己的时间。 没必要写的非常多，毕竟case维护成本很高，业务逻辑一改，case得跟着改。</p><p>最后说一句：当开发完功能，跑完UT，你可以放心的上线了的时候，你的UT就成功了。</p>',48),p=[n];function d(h,g){return e(),a("div",null,p)}const f=i(r,[["render",d],["__file","unit-test-basic.html.vue"]]);export{f as default};
